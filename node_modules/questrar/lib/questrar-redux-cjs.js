'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('react');

//status flags
var PENDING = 'pending';
var SUCCESS = 'success';
var FAILED = 'failed';

//action flags
var REPLACE = 'replace';
var REMOVE = 'remove';
var CLEAN = 'clean';
var DIRTY = 'clean';

//Initial request state
var initialRequest = {
  pending: false,
  success: false,
  failed: false,
  successCount: 0,
  failureCount: 0,
  message: '',
  clean: true
};

//Default redux store path to request state object
var REDUX_STATE_PATH = '';

//Default redux reducer id / redux store object id
var REQUEST_ACTION_TYPE = '__QUESTRAR_REQUEST_';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var NODE_ENV = process.env.NODE_ENV;

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var invariant_1 = invariant;

/**
 * Reset a request flags to initial state.
 * Setting pending, success and failed to false
 *
 * @param req
 * @returns {Request}
 */
var resetRequestFlags = function resetRequestFlags(req) {
  var r = req;
  r.pending = false;
  r.success = false;
  r.failed = false;
  if (r.message) {
    delete r.message;
  }
  return r;
};

/**
 * Creates a random string of length less than 15 characters with [a - h]
 * @param length
 * @returns {string}
 */
function randomId() {
  var rand = Math.random();
  return rand.toString().split('.')[1];
}

/**
 * Checks if arg is a function
 *
 * @param func
 * @returns {boolean}
 */
function isFunc(func) {
  return typeof func === "function";
}

/**
 * Checks if arg is an object and not null
 * @param num
 * @returns {any|boolean}
 */
function isNumber(num) {
  return typeof num === "number";
}

/**
 * Assert if value is not null or not undefined
 *
 * @param value
 * @returns {boolean}
 */
function nonEmpty(value) {
  return typeof value !== 'undefined' && value !== null;
}

/**
 * Configuration type for request action
 */


/**
 * Creates a redux requestState action to update request state in redux store
 *
 * @param id
 * @param options
 * @returns {function(Object=, string=, RequestOptions=)}
 */
function createRequest(id, options) {
  var reduxActionType = REQUEST_ACTION_TYPE;

  var isStatic = nonEmpty(id) && (typeof id === 'string' || isNumber(id));
  var hasOptions = nonEmpty(options);

  var autoRemove = hasOptions && options.autoRemove;
  var autoRemoveOnSuccess = hasOptions && options.autoRemoveOnSuccess;
  var autoRemoveOnFailure = hasOptions && options.autoRemoveOnFailure;

  var requestId = isStatic ? id : randomId();

  /**
   * Creates an action to update a request in redux store
   * @param rId Request id
   * @param status Update status of request
   * @param message Optional message for current update
   * @returns {{type: string, id: (string|number), status: string}}
   */
  var initAction = function initAction(rId, status, message) {
    var _action = { type: reduxActionType, id: rId, status: status };
    if (nonEmpty(message)) {
      _action.message = message;
    }
    return _action;
  };

  /**
   * Creates a pending request action
   * @param message Optional message for update pending
   * @returns {{type: string, id: (string|number), status: string}}
   */
  var pending = function pending(message) {
    return initAction(requestId, PENDING, message);
  };

  /**
   * Creates a request successful action
   * @param message Optional message for update
   * @param remove Removes request on close success
   * @returns {{type: string, id: (string|number), status: string} & {autoRemove: boolean, autoRemoveOnSuccess: boolean}}
   */
  var success = function success(message, remove) {
    var action = initAction(requestId, SUCCESS, message);
    if (nonEmpty(remove)) {
      action.autoRemoveOnSuccess = remove;
    } else {
      action.autoRemoveOnSuccess = autoRemoveOnFailure;
    }
    return Object.assign(action, { autoRemove: autoRemove, autoRemoveOnSuccess: autoRemoveOnSuccess });
  };

  /**
   *
   * Creates a request failed action
   * @param message Optional message for update
   * @param remove Removes request on close failure
   * @returns {{type: string, id: (string|number), status: string} & {autoRemove: boolean}}
   */
  var failed = function failed(message, remove) {
    var action = initAction(requestId, FAILED, message);
    if (nonEmpty(remove)) {
      action.autoRemoveOnFailure = remove;
    } else {
      action.autoRemoveOnFailure = autoRemoveOnFailure;
    }
    return Object.assign(action, { autoRemove: autoRemove });
  };

  /**
   * Creates action to set request as clean
   * @returns {{type: string, id: *, status: *}}
   */
  var clean = function clean() {
    return initAction(requestId, CLEAN);
  };

  /**
   * Creates action to set request as dirty (clean === false)
   * @returns {{type: string, id: *, status: *}}
   */
  var dirty = function dirty() {
    return initAction(requestId, DIRTY);
  };

  /**
   * Creates an action to remove a specific request state
   * @returns {{type: string, id: (string|number), status: string}}
   */
  var remove = function remove() {
    return initAction(requestId, REMOVE);
  };

  /**
   * Action binder function
   * @returns {*}
   */
  function actionCreator() {
    return requestId;
  }

  actionCreator.toString = function () {
    return requestId;
  };

  actionCreator.id = requestId;

  actionCreator.pending = pending;
  actionCreator.success = success;
  actionCreator.failed = failed;

  actionCreator.clean = clean;
  actionCreator.dirty = dirty;

  actionCreator.remove = remove;

  return actionCreator;
}

/**
 * Create a redux to questrar request state mapper
 * It uses replace state to sync from provider to redux and back
 *
 * if path is more than one level deep in the store state, path should be delimited by a dot (.)
 * e.g. 'app.operation.ticket' === { app: { operation: { ticket: { requestState }}}}
 *
 * @param store The redux store
 * @param path The store path of request state
 * @returns {{getState: getState, putState: putState}}
 */
function createStateProvider(store, path) {

  var s = store;

  /**
   *  Request state identity
   *  Since no two symbol created (Symbol()) are not equal
   *  every time an update is made to store, a new symbol should be created
   *  On store state change, symbol realizes change in request state object forcing update to context provider
   */
  var id = void 0;

  /**
   * Unsubscribe function
   */
  var unsubscribe = void 0;

  /**
   * Redux store absolute path to request state
   * i.e. user preferred state path + reducer id
   *
   * @type {string}
   * @private
   */
  var _path = (path || REDUX_STATE_PATH) + '.' + REQUEST_ACTION_TYPE;

  /**
   * Gets the redux request state current
   * @returns {*}
   */
  function getRawState() {
    var state = s.getState();
    var paths = _path.split('.');
    var rState = state;
    for (var i = 0; i < paths.length; i++) {
      if (paths[i] && Object.hasOwnProperty.call(rState, paths[i])) {
        rState = state[paths[i]];
      }
    }
    return rState;
  }

  /**
   * Get state data
   * @returns {*}
   */
  function getState() {
    var state = getRawState();
    if (nonEmpty(state) && nonEmpty(state.data)) {
      return state.data;
    }
    return {};
  }

  /**
   * Replace the entire request state into redux
   * CAVEAT: Prone to corrupt request state
   * TODO: dispatch requestState specific update
   *
   * @param state
   */
  function putState(state) {
    s.dispatch({ type: REPLACE, payload: state });
  }

  /**
   * Run update to the Request provider
   * @param update
   * @returns {Function}
   * @private
   */
  function runUpdate(update) {
    return function () {
      var _s = getRawState();
      if (Object.hasOwnProperty.call(_s, 'id')) {
        if (_s.id !== id) {
          //update if state id has changed since the last update
          id = _s.id;
          update(true);
        }
      }
    };
  }

  /**
   * Watches the request state and forces update of RequestProvider if there's been a change.
   *
   * CAVEAT: Calls update with true on any little update in any store state
   * TODO: Track changes only on requestState in store
   *
   * @param update
   */
  function observe(update) {
    unsubscribe = store.subscribe(runUpdate(update));
  }

  /**
   * Releases resources attached to store
   */
  function release() {
    if (isFunc(unsubscribe)) {
      unsubscribe();
    }
  }

  /**
   * Dispatch request state specific updates to redux store
   * @param action
   */
  function updateRequest(action) {
    var req = createRequest(action.id, action);
    var _action = void 0;
    switch (action.status) {
      case PENDING:
        _action = req.pending(action.message);
        break;
      case FAILED:
        _action = req.failed(action.message);
        break;
      case SUCCESS:
        _action = req.success(action.message);
        break;
      case REMOVE:
        _action = req.remove();
        break;
      default:
        break;
    }
    if (nonEmpty(_action)) {
      s.dispatch(_action);
    }
  }

  return {
    getState: getState, putState: putState, updateRequest: updateRequest, observe: observe, release: release, path: _path
  };
}

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/**
 * Sets remove flags on request.
 * Removes control removal of requestState on close of RequestComponent feature `onCloseError` or `onCloseSuccess`
 * @param state
 * @param action
 * @returns {*}
 */
function setRemoves(state, action) {
  var s = state;

  if (action.autoRemove) {
    s.autoRemove = true;
  }
  if (action.autoRemoveOnSuccess) {
    s.removeOnSuccess = true;
    if (s.autoRemove) {
      delete s['autoRemove'];
    }
    return s;
  }

  if (action.autoRemoveOnFailure) {
    s.removeOnFail = true;
    if (s.autoRemove) {
      delete s['autoRemove'];
    }
    return s;
  }

  return s;
}

/**
 * Get requestState from state by request id
 * @param state
 * @param id
 * @returns {*}
 */
function getState(state, id) {
  if (Object.hasOwnProperty.call(state, id)) {
    return Object.assign({}, state[id]);
  }
  return initialRequest;
}

/**
 * Set request state message if provided as part of action
 * @param state
 * @param action
 */
function setMessage(state, action) {
  if (action.message) {
    state.message = action.message;
  }
}

/**
 * Updates a request to pending
 *
 * @returns {{} & RequestState}
 */
function handleRequestPending(state, action) {
  invariant_1(nonEmpty(action.id), 'request action missing id field');

  var id = action.id;
  var stateId = Symbol(id);

  var nextReq = resetRequestFlags(getState(state.data, id));
  nextReq.id = id;
  nextReq.pending = true;
  nextReq.clean = true;
  setMessage(nextReq, action);

  var data = Object.assign({}, state.data, defineProperty({}, id, nextReq));
  return { id: stateId, data: data };
}

/**
 * Updates a request to clean state
 *
 * @returns {{} & RequestState}
 */
function handleRequestClean(state, action) {
  invariant_1(nonEmpty(action.id), 'request action missing id field');

  var id = action.id;
  var stateId = Symbol(id);

  var nextReq = resetRequestFlags(getState(state.data, id));
  nextReq.id = id;
  nextReq.clean = true;

  var data = Object.assign({}, state.data, defineProperty({}, id, nextReq));
  return { id: stateId, data: data };
}

/**
 * Updates a request to dirty state
 *
 * @returns {{} & RequestState}
 */
function handleRequestDirty(state, action) {
  invariant_1(nonEmpty(action.id), 'request action missing id field');

  var id = action.id;
  var stateId = Symbol(id);

  var nextReq = resetRequestFlags(getState(state.data, id));
  nextReq.id = id;
  nextReq.clean = false;

  var data = Object.assign({}, state.data, defineProperty({}, id, nextReq));
  return { id: stateId, data: data };
}

/**
 * Updates a request state to failed
 * @params state, action
 * @returns {{} & RequestState}
 */
function handleRequestFailed(state, action) {
  invariant_1(nonEmpty(action.id), 'request state action missing id field');

  var id = action.id;
  var stateId = Symbol(id);

  var nextReq = resetRequestFlags(getState(state.data, id));
  nextReq.id = id;
  nextReq.failed = true;
  nextReq.failureCount += 1;
  setMessage(nextReq, action);
  setRemoves(nextReq, action);

  var data = Object.assign({}, state.data, defineProperty({}, id, nextReq));
  return { id: stateId, data: data };
}

/**
 * Updates a request state to success.
 * Autodeletes a request if set to true
 *
 * @params state, action
 * @returns {{} & RequestState}
 */
function handleRequestSuccess(state, action) {
  invariant_1(nonEmpty(action.id), 'request state action missing id field');

  var id = action.id;
  var stateId = Symbol(id);

  var nextReq = resetRequestFlags(getState(state, id));
  nextReq.id = id;
  nextReq.success = true;
  nextReq.successCount += 1;
  setMessage(nextReq, action);
  setRemoves(nextReq, action);

  var data = Object.assign({}, state.data, defineProperty({}, id, nextReq));
  return { id: stateId, data: data };
}

/**
 * Remove request state from redux
 * @param state
 * @param action
 * @returns {*}
 */
function removeRequestState(state, action) {
  invariant_1(nonEmpty(action.id), 'request action missing id field');

  var stateId = Symbol();
  var id = action.id;

  if (Object.hasOwnProperty.call(state.data, id)) {
    var data = Object.assign({}, state.data);
    delete data[id];
    return { id: stateId, data: data };
  }
  return Object.assign({}, state);
}

/**
 * Replaces the whole request state with a new state
 *
 * @param state
 * @param action
 * @returns {*}
 */
var replaceState = function replaceState(state, action) {
  var stateId = Symbol();

  return Object.assign({}, { data: action.state, id: stateId });
};

/**
 * Request state reducer for redux
 * @param state Initial state
 * @param action redux action dispatched
 * @returns {*} Final state
 */
function rootReducer(state, action) {
  var _state = Object.assign({ data: {} }, state);
  switch (action.status) {
    case PENDING:
      return handleRequestPending(_state, action);

    case SUCCESS:
      return handleRequestSuccess(_state, action);

    case FAILED:
      return handleRequestFailed(_state, action);

    case CLEAN:
      return handleRequestClean(_state, action);

    case DIRTY:
      return handleRequestDirty(_state, action);

    case REPLACE:
      return replaceState(_state, action);

    case REMOVE:
      return removeRequestState(_state, action);

    default:
      {
        return _state;
      }
  }
}

var RequestReducer = defineProperty({}, REQUEST_ACTION_TYPE, rootReducer);

exports.createRequestState = createRequest;
exports.createStateProvider = createStateProvider;
exports.requestStateReducer = RequestReducer;
//# sourceMappingURL=questrar-redux-cjs.js.map
